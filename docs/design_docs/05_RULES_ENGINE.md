# 05 — Rules Engine

> *If this happens, then do that.  Everything else is configuration.*

---

## 5.1 Overview

The Rules Engine is the **decision-making core** of Synapse.  It replaces
the v3.0 Reward Engine's hardcoded pipeline with a configurable
**trigger → condition → effect** system.

```
Event Lake entry → [Match Triggers] → [Evaluate Conditions] → [Apply Effects] → Ledger Transactions
```

In v3.0, the pipeline was:

```
SynapseEvent → Zone Classify → Multiply → Quality → Anti-Gaming → Cap → RewardResult
```

Every stage was a Python function.  To change the formula, you changed
code.  In v4.0, each of those stages becomes a **Rule** — a JSON object
stored in the database that admins can create, clone, disable, and tune
through the dashboard.

---

## 5.2 What Is a Rule?

A Rule is the atomic unit of the engine.  It answers one question:
**"When X happens, under conditions Y, do Z."**

```json
{
  "id": "msg-xp-award",
  "name": "Message XP Award",
  "description": "Award XP when a member sends a qualifying message",
  "enabled": true,
  "priority": 100,
  "module": "economy",

  "trigger": {
    "event_type": "message_create",
    "zone_filter": null
  },

  "conditions": [
    { "type": "not_self_interaction" },
    { "type": "min_length", "params": { "min": 5 } },
    { "type": "daily_cap_not_reached", "params": { "currency": "xp", "max": 5000 } }
  ],

  "effects": [
    {
      "type": "ledger_credit",
      "params": {
        "currency": "xp",
        "amount_expr": "base * zone_multiplier * quality_modifier",
        "base": 15
      }
    },
    {
      "type": "ledger_credit",
      "params": {
        "currency": "stars",
        "amount_expr": "1",
        "base": 1
      }
    }
  ]
}
```

### Rule Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique slug identifier |
| `name` | string | Human-readable name (shown in admin) |
| `description` | string | What this rule does (shown in admin) |
| `enabled` | bool | Toggle without deleting |
| `priority` | int | Evaluation order (lower = first).  Allows "stop" rules |
| `module` | string | Which module owns this rule (economy, milestones, etc.) |
| `trigger` | Trigger | What event type activates this rule |
| `conditions` | Condition[] | All must pass for effects to fire |
| `effects` | Effect[] | Actions to take when conditions pass |
| `stop_processing` | bool | If true, no further rules evaluate for this event |

---

## 5.3 Triggers

A Trigger binds a rule to one or more event types from the Event Lake.

| Property | Description |
|----------|-------------|
| `event_type` | The event type to match.  `"*"` matches all. |
| `zone_filter` | Optional zone slug.  If set, only fires for events in this zone. |
| `channel_filter` | Optional channel ID.  Overrides zone_filter for precision. |

### Event Types

These are the event categories from the Event Lake (see 03B for the
complete schema once research is finalized):

| Event Type | Source | Description |
|------------|--------|-------------|
| `message_create` | Gateway | Member sent a message |
| `reaction_add` | Gateway | Reaction added to a message |
| `thread_create` | Gateway | New thread started |
| `voice_session_end` | Derived | Voice session completed (with duration) |
| `member_join` | Gateway | New member joined the guild |
| `level_up` | Internal | A member's level increased |
| `milestone_earned` | Internal | A milestone was achieved |
| `manual_award` | Command | Admin used `/award` |
| `season_roll` | System | A season boundary was crossed |

> **Note:** Internal events are generated by Synapse itself (not Discord)
> and allow rules to chain.  E.g., a `level_up` event can trigger a rule
> that awards Gold.

---

## 5.4 Conditions (The Filter Layer)

Conditions are predicates that must ALL evaluate to `true` for the rule's
effects to fire.  They replace the hardcoded stages of the v3.0 pipeline.

### Built-in Condition Types

| Condition | Params | Replaces (v3.0) |
|-----------|--------|-----------------|
| `not_self_interaction` | — | Hardcoded self-award check |
| `min_length` | `min: int` | — (new) |
| `max_emoji_ratio` | `max_ratio: float` | Hardcoded emoji spam penalty |
| `daily_cap_not_reached` | `currency: str, max: int` | `xp_daily_max` config |
| `pair_rate_limit` | `window_minutes: int, max: int` | Hardcoded per-user per-target cap |
| `unique_reactors_min` | `min: int` | Hardcoded unique-reactor weighting |
| `reaction_velocity_cap` | `window_minutes: int, max: int` | Hardcoded reaction velocity check |
| `voice_not_idle` | — | `is_muted AND is_deafened` check |
| `cooldown` | `seconds: int` | Rate limit per user per rule |
| `has_role` | `role_id: int` | — (new, role gating) |
| `zone_is` | `zone: str` | Zone classification stage |
| `expression` | `expr: str` | — (new, freeform) |

### Condition Evaluation

```python
def evaluate_conditions(rule: Rule, event: EventLakeEntry, ctx: RuleContext) -> bool:
    """All conditions must pass.  Short-circuits on first failure."""
    for cond in rule.conditions:
        handler = CONDITION_REGISTRY[cond.type]
        if not handler(cond.params, event, ctx):
            return False
    return True
```

The condition registry is a dictionary of `{type_name: callable}`.  This
is extensible — new condition types can be added via Python without
altering the schema.

---

## 5.5 Effects (The Action Layer)

Effects are the actions taken when a rule fires.  Multiple effects per rule
are supported and execute in order.

### Built-in Effect Types

| Effect | Params | Description |
|--------|--------|-------------|
| `ledger_credit` | `currency, amount_expr, base` | Add currency to the actor's wallet |
| `ledger_credit_target` | `currency, amount_expr, base` | Add currency to the event target's wallet |
| `ledger_debit` | `currency, amount_expr` | Remove currency from actor's wallet |
| `milestone_check` | — | Re-evaluate milestones for the actor |
| `announce` | `template: str` | Post an announcement embed to the configured channel |
| `assign_role` | `role_id: int` | Grant a Discord role |
| `remove_role` | `role_id: int` | Remove a Discord role |
| `log` | `message: str` | Write to audit log |

### Amount Expressions

The `amount_expr` field supports a simple expression language for
computing dynamic amounts:

```
base * zone_multiplier * quality_modifier
```

Available variables in the expression context:

| Variable | Description |
|----------|-------------|
| `base` | The `base` param from the effect |
| `zone_multiplier` | The zone's multiplier for this event type |
| `quality_modifier` | Message quality score (§5.6) |
| `event.metadata.*` | Any metadata field from the event |
| `user.level` | The actor's current level |
| `user.wallet(currency)` | The actor's balance in a currency |
| `random(min, max)` | Random integer in range |

> **Decision D05-01:** Amount expressions are evaluated in a sandboxed
> context with no access to imports, builtins, or the database.  They
> are arithmetic-only.  This prevents admin-authored rules from becoming
> a security vector.

---

## 5.6 Quality Modifier (Built-in Calculator)

The Quality Modifier is a **built-in function** available to amount
expressions.  It examines message metadata and returns a multiplier.

This is the one piece of "hardcoded logic" that remains, because quality
assessment is complex enough that expressing it as rule conditions would
be unwieldy.  However, its thresholds are configurable:

| Modifier | Default Threshold | Default Multiplier | Configurable |
|----------|------------------|-------------------|-------------|
| Length Bonus | `length > 200` | ×1.2 | ✔ |
| Long-Form Bonus | `length > 500` | ×1.5 | ✔ |
| Code Block | `has_code_block` | ×1.4 | ✔ |
| Link Enrichment | `has_link` | ×1.25 | ✔ |
| Attachment | `has_attachment` | ×1.1 | ✔ |
| Emoji Spam | `emoji_ratio > 0.3` | ×0.5 | ✔ |

The quality calculator is invoked automatically when `quality_modifier`
appears in an amount expression.  If an admin prefers to write their own
quality logic as separate rules, they can omit `quality_modifier` from
the expression and create condition-based rules instead.

---

## 5.7 Rule Evaluation Pipeline

When an event enters the Event Lake:

```
1. Event Lake INSERT
2. Rules Engine receives event
3. Load all enabled rules, sorted by priority
4. For each rule:
   a. Does the trigger match this event? (event_type + zone/channel filter)
   b. Do all conditions pass?
   c. If yes: execute all effects
   d. If rule.stop_processing: break
5. Commit all ledger transactions in a single DB transaction
6. Return summary of applied rules + effects
```

### Batching and Performance

- Rules are **cached in memory** and refreshed via PG NOTIFY when changed.
- Condition evaluation is cheap (no DB queries — all context is
  pre-loaded in `RuleContext`).
- Ledger writes are batched: all effects from all matching rules for a
  single event are committed in one transaction.
- The engine targets **< 5ms per event** for a typical rule set of 20–50
  rules.

---

## 5.8 The Zone → Multiplier Bridge

In v3.0, Zones directly held per-event-type XP/Star multipliers.  In v4.0,
Zones still exist as **Region** definitions (channel groupings), but the
"multiplier" concept is expressed through rules:

**v3.0 (hardcoded):**
```
programming zone, MESSAGE → xp_multiplier: 1.5, star_multiplier: 1.0
```

**v4.0 (rule-based):**
```json
{
  "id": "msg-xp-programming-boost",
  "trigger": { "event_type": "message_create", "zone_filter": "programming" },
  "conditions": [],
  "effects": [{
    "type": "ledger_credit",
    "params": { "currency": "xp", "amount_expr": "base * 1.5 * quality_modifier", "base": 15 }
  }]
}
```

Or more elegantly, the zone's multiplier value is stored in the zone table
and exposed as `zone_multiplier` in the expression context, preserving the
v3.0 admin experience of "just set a number per zone per event type" while
routing it through the rules engine internally.

---

## 5.9 Presets

A **Preset** is a bundled collection of rules that can be imported with
one click.  Presets solve the "blank canvas" problem — no admin should
have to author 30 rules from scratch to get started.

### Classic Gamification Preset

Ships with Synapse.  Reproduces the v3.0 behavior exactly:

| Rule | Trigger | Key Conditions | Effects |
|------|---------|----------------|---------|
| Message XP | `message_create` | min_length(5), daily_cap(5000) | xp: base×zone×quality |
| Message Stars | `message_create` | — | stars: 1 |
| Reaction Given XP | `reaction_add` (actor) | pair_rate_limit(24h, 3) | xp: 2×zone |
| Reaction Received XP | `reaction_add` (target) | unique_reactors(2), velocity_cap(5min, 10) | xp: 3×zone |
| Thread Create XP | `thread_create` | cooldown(300s) | xp: 20×zone |
| Voice Tick | `voice_session_end` | not_idle | stars: mins/10 |
| Level Up Bonus | `level_up` | — | gold: 50 |

### Analytics Only Preset

No economy rules.  Event Lake captures data; dashboard shows metrics.

| Rule | Trigger | Effects |
|------|---------|---------|
| (none) | — | — |

All rules are disabled.  The Event Lake still captures events.  The dashboard
shows activity heatmaps, member counts, and channel usage without any
currency system.

### Minimal Engagement Preset

A lightweight engagement system without the full gamification weight:

| Rule | Trigger | Effects |
|------|---------|---------|
| Participation Point | `message_create` | karma: 1 |
| Voice Participation | `voice_session_end` | karma: mins/10 |
| Weekly Highlight | (manual trigger) | announce |

---

## 5.10 Rule Authoring in the Admin UI

The dashboard provides a visual rule builder:

1. **Rule List** — Table of all rules, grouped by module, with
   enable/disable toggles and priority drag-and-drop.
2. **Rule Editor** — Form-based builder:
   - Trigger selector (dropdown of event types + optional zone filter)
   - Condition builder (add conditions from dropdown, configure params)
   - Effect builder (add effects from dropdown, configure params)
   - Amount expression editor with syntax highlighting and preview
3. **Preset Import** — One-click import of a preset.  Imported rules are
   fully editable after import.
4. **Dry Run** — Paste a sample event JSON and see which rules fire and
   what the outcome would be.
5. **Rule Templates** — Save any rule as a template for reuse.

---

## Decisions

> **Decision D05-01:** Sandboxed Amount Expressions
> - **Status:** Accepted (New in v4.0)
> - **Context:** Admins need dynamic amount calculations but must not
>   have arbitrary code execution.
> - **Choice:** Amount expressions are arithmetic-only, evaluated in a
>   restricted context with predefined variables.  No imports, no
>   builtins, no database access.
> - **Consequences:** Safe for user-authored rules.  Limited to math.

> **Decision D05-02:** Rules as JSON in Database
> - **Status:** Accepted (Supersedes hardcoded pipeline in v4.0)
> - **Context:** v3.0's reward pipeline was Python code.  Changing
>   behavior required code changes and redeployment.
> - **Choice:** Rules are JSONB documents in a `rules` table, loaded
>   into memory, and refreshed via PG NOTIFY.
> - **Consequences:** Hot-reloadable rules.  No redeployment for config
>   changes.  Testable via dry-run.

> **Decision D05-03:** Quality Modifier Stays as Built-in
> - **Status:** Accepted (New in v4.0)
> - **Context:** Quality assessment involves multiple stacking multipliers
>   that would be awkward to express as separate rules.
> - **Choice:** Keep quality modifier as a built-in calculator callable
>   from amount expressions.  Its thresholds are configurable via settings.
> - **Consequences:** Clean UX for the common case.  Admins who want fully
>   custom quality logic can ignore it and write their own rules instead.

> **Decision D05-04:** Presets for Zero-Config Start
> - **Status:** Accepted (New in v4.0)
> - **Context:** A blank rules canvas is overwhelming.  Most admins want
>   to start with something that works and tweak from there.
> - **Choice:** Ship bundled presets (Classic Gamification, Analytics Only,
>   Minimal Engagement).  Presets import as editable rules.
> - **Consequences:** Instant start.  No lock-in — every imported rule is
>   editable.  Presets can be community-contributed in the future.

> **Decision D05-05:** Event Chaining via Internal Events
> - **Status:** Accepted (New in v4.0)
> - **Context:** Some rules should fire on outcomes of other rules (e.g.,
>   award Gold on level-up).
> - **Choice:** The Rules Engine emits internal events (`level_up`,
>   `milestone_earned`, `season_roll`) that can trigger further rules.
> - **Consequences:** Powerful chaining.  Risk of infinite loops mitigated
>   by a chain depth limit (default: 3).
